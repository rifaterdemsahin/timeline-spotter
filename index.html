<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Spotter - Artifact Location Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }

        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 2px solid #e9ecef;
        }

        .section h2 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }

        .section h2::before {
            content: "‚ñ∂";
            margin-right: 10px;
            color: #667eea;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #495057;
            font-weight: 600;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            margin-bottom: 15px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: 'Courier New', monospace;
        }

        input[type="file"] {
            margin-bottom: 15px;
            padding: 10px;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            width: 100%;
            cursor: pointer;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #6c757d;
        }

        button.danger {
            background: #dc3545;
        }

        .timeline-container {
            margin-top: 20px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 2px solid #dee2e6;
        }

        .timeline {
            position: relative;
            height: 100px;
            background: linear-gradient(to right, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #dee2e6;
        }

        .timeline-marker {
            position: absolute;
            bottom: 0;
            width: 3px;
            height: 100%;
            background: rgba(102, 126, 234, 0.3);
        }

        .artifact-marker {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #667eea;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .artifact-marker:hover {
            transform: translateY(-50%) scale(1.3);
        }

        .artifact-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #667eea;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            white-space: nowrap;
            display: none;
        }

        .artifact-marker:hover .artifact-label {
            display: block;
        }

        .results {
            margin-top: 20px;
        }

        .result-item {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .result-item strong {
            color: #667eea;
        }

        .cookie-list {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .cookie-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .cookie-item button {
            padding: 5px 10px;
            font-size: 0.9em;
            margin: 0;
        }

        .script-timeline {
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }

        .script-segment {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .script-time {
            font-weight: bold;
            color: #667eea;
            min-width: 120px;
        }

        .script-text {
            flex: 1;
            margin: 0 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .script-copy-btn {
            padding: 5px 10px;
            font-size: 0.8em;
        }

        .script-segment.highlighted {
            background: #fff3cd;
            border-color: #ffc107;
            box-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .timeline-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .timeline-table-container {
            max-height: 400px;
            overflow-y: auto;
        }

        .timeline-table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        .timeline-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }

        .timeline-table tr:hover {
            background: #f8f9fa;
        }

        .timeline-table .time-col {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #667eea;
            min-width: 120px;
        }

        .timeline-table .text-col {
            max-width: 400px;
        }

        .timeline-table .actions-col {
            min-width: 150px;
        }

        .timeline-table .actions-col button {
            margin-right: 5px;
            padding: 5px 8px;
            font-size: 0.8em;
        }

        .timeline-controls {
            margin-bottom: 10px;
            display: flex;
            gap: 10px;
        }

        .timeline-controls button {
            padding: 8px 12px;
            font-size: 0.9em;
        }

        .timeline-table tr.highlighted {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }

        .result-group {
            margin-bottom: 20px;
        }

        .result-group h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .keywords-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .keyword-tag {
            background: #667eea;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .keyword-tag:hover {
            background: #5a67d8;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #c3e6cb;
            display: none;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #f5c6cb;
            display: none;
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Timeline Spotter</h1>
        <p class="subtitle">Find location for your artifacts on a non-linear video editor</p>

        <div id="successMessage" class="success-message"></div>
        <div id="errorMessage" class="error-message"></div>

        <div class="info-box">
            <strong>‚ÑπÔ∏è How to use:</strong> Configure your timeline length, upload subtitles and artifacts, then use the search function to find optimal locations for your artifacts. All data is saved locally for persistence.
        </div>

        <!-- File Uploads -->
        <div class="section">
            <h2>üìÅ Upload Files</h2>
            <label for="subtitleFile">üé¨ Upload Subtitle File (.srt, .vtt):</label>
            <input type="file" id="subtitleFile" accept=".srt,.vtt,.txt" onchange="handleSubtitleUpload(event)">



        </div>

        <!-- Search Function -->
        <div class="section">
            <h2>üîç Search Artifacts</h2>
            <label for="searchQuery">Search for artifact locations:</label>
            <input type="text" id="searchQuery" placeholder="e.g., intro, transition, logo, music cue" autocomplete="off" list="keywordsList">
            <datalist id="keywordsList"></datalist>
            <button onclick="searchArtifacts()">üîç Find Locations</button>

            <div id="searchResults" class="results"></div>
        </div>

        <!-- Keywords -->
        <div class="section" id="keywordsSection" style="display: none;">
            <h2>üìù Keywords from Subtitles</h2>
            <p>Click keywords to add them to your search query:</p>
            <div id="keywordsContainer" class="keywords-container"></div>
            <button onclick="regenerateKeywords()">üîÑ Regenerate from Subtitles</button>
        </div>

        <!-- Actual Timeline -->
        <div class="section" id="actualTimelineSection" style="display: none;">
            <h2>üé¨ Actual Timeline (from Subtitles) <button onclick="toggleTimelineExpansion()" id="expandBtn">üîΩ Expand</button></h2>
            <div class="timeline-controls">
                <button onclick="selectAllEntries()">Select All</button>
                <button onclick="deselectAllEntries()">Deselect All</button>
                <button onclick="exportSelectedAsSRT()">Export Selected as SRT</button>
            </div>
            <div class="timeline-table-container" id="timelineContainer">
                <table id="actualTimelineTable" class="timeline-table">
                    <thead>
                        <tr>
                            <th><input type="checkbox" id="selectAllCheckbox" onchange="toggleAllCheckboxes()"></th>
                            <th>Start Time</th>
                            <th>End Time</th>
                            <th>Text</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>



        <!-- Data Management -->
        <div class="section">
            <h2>Data Management</h2>
            <button onclick="viewStorageItems()">üëÅÔ∏è View All Stored Data</button>
            <button onclick="clearAllStorageItems()" class="danger">üóëÔ∏è Clear All Stored Data</button>
            <button onclick="exportData()" class="secondary">üíæ Export Data</button>
            <button onclick="importData()" class="secondary">üìÇ Import Data</button>

            <div id="cookieList" class="cookie-list" style="display: none;"></div>
        </div>
    </div>

    <script>
        // Constants
        const ARTIFACT_COLORS = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#43e97b', '#fa709a'];
        const TRANSITION_MIN_POSITION = 30;
        const TRANSITION_RANGE = 40;
        const INTRO_POSITION = 5;
        const OUTRO_POSITION = 95;
        const MIDDLE_POSITION = 50;

        // Local Storage Management Functions
        function setStorageItem(name, value) {
            localStorage.setItem(name, value);
        }

        function getStorageItem(name) {
            return localStorage.getItem(name);
        }

        function removeStorageItem(name) {
            localStorage.removeItem(name);
        }

        function getAllStorageItems() {
            const items = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                items[key] = localStorage.getItem(key);
            }
            return items;
        }

        // Timeline Management
        let timelineData = {
            length: 300,
            unit: 'seconds',
            artifacts: []
        };



        function updateTimeline() {
            const minutes = parseInt(document.getElementById('timelineMinutes').value);
            const seconds = parseInt(document.getElementById('timelineSeconds').value);
            const length = minutes * 60 + seconds;
            const unit = document.getElementById('timelineUnit').value;

            timelineData.length = length;
            timelineData.unit = unit;

            setStorageItem('timeline_length', length.toString());
            setStorageItem('timeline_unit', unit);

            showMessage('Timeline updated successfully!', 'success');
        }

        function renderTimeline() {
            const timeline = document.getElementById('timeline');
            const info = document.getElementById('timelineInfo');
            
            timeline.innerHTML = '';
            
            // Add time markers
            for (let i = 0; i <= 10; i++) {
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';
                marker.style.left = (i * 10) + '%';
                timeline.appendChild(marker);
            }
            
            // Display timeline info
            const duration = formatDuration(timelineData.length, timelineData.unit);
            info.textContent = `Timeline: 0 to ${duration}`;
            
            // Render artifacts
            timelineData.artifacts.forEach((artifact, index) => {
                const marker = document.createElement('div');
                marker.className = 'artifact-marker';
                marker.style.left = artifact.position + '%';
                marker.style.background = artifact.color || '#667eea';
                marker.innerHTML = `<div class="artifact-label">${artifact.name} (${artifact.time})</div>`;
                marker.onclick = () => showArtifactDetails(artifact);
                timeline.appendChild(marker);
            });
            
            updateArtifactList();
        }

        function formatDuration(value, unit) {
            if (unit === 'seconds') {
                const mins = Math.floor(value / 60);
                const secs = value % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            } else if (unit === 'frames') {
                return `${value} frames`;
            } else {
                return value;
            }
        }

        // Subtitle Processing
        let subtitleData = [];

        function handleSubtitleUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                subtitleData = parseSubtitles(content);
                setStorageItem('timeline_subtitles', JSON.stringify(subtitleData));
                showMessage(`Subtitle file uploaded: ${subtitleData.length} entries parsed.`, 'success');
                renderActualTimeline();
                // Show keywords section and extract keywords
                document.getElementById('keywordsSection').style.display = 'block';
                regenerateKeywords();
            };
            reader.readAsText(file);
        }

        function parseSubtitles(content) {
            const lines = content.split('\n');
            const subtitles = [];
            let currentSubtitle = {};
            
            for (let line of lines) {
                line = line.trim();
                
                // Time code line (e.g., 00:00:01,000 --> 00:00:04,000)
                if (line.includes('-->')) {
                    const [start, end] = line.split('-->').map(t => t.trim());
                    currentSubtitle.start = parseTimecode(start);
                    currentSubtitle.end = parseTimecode(end);
                }
                // Text content
                else if (line && !line.match(/^\d+$/) && currentSubtitle.start !== undefined) {
                    if (!currentSubtitle.text) {
                        currentSubtitle.text = line;
                    } else {
                        currentSubtitle.text += ' ' + line;
                    }
                }
                // Empty line - end of subtitle block
                else if (line === '' && currentSubtitle.text) {
                    subtitles.push({...currentSubtitle});
                    currentSubtitle = {};
                }
            }
            
            return subtitles;
        }

        function parseTimecode(timecode) {
            // Parse formats like 00:00:01,000 or 00:00:01.000
            const parts = timecode.replace(',', '.').split(':');
            const hours = parseInt(parts[0]) || 0;
            const minutes = parseInt(parts[1]) || 0;
            const seconds = parseFloat(parts[2]) || 0;
            return hours * 3600 + minutes * 60 + seconds;
        }

        // Artifact Management
        let artifactList = [];



        // Build context from surrounding subtitle entries to get ~100+ words
        function buildSubtitleContext(matchIndex) {
            const allTexts = subtitleData.map(s => s.text);
            // Start from the matched subtitle and expand outward until we have enough words
            let combined = allTexts[matchIndex];
            let left = matchIndex - 1;
            let right = matchIndex + 1;

            while (combined.split(/\s+/).length < BUFFER_SIZE && (left >= 0 || right < allTexts.length)) {
                if (left >= 0) {
                    combined = allTexts[left] + ' ' + combined;
                    left--;
                }
                if (right < allTexts.length) {
                    combined = combined + ' ' + allTexts[right];
                    right++;
                }
            }
            return combined;
        }

        // Search Function
        function searchArtifacts() {
            const input = document.getElementById('searchQuery');
            const query = input.value.trim().toLowerCase();
            input.value = input.value.trim(); // Update the input to show trimmed value
            if (!query) {
                showMessage('Please enter a search query.', 'error');
                return;
            }
            
            const results = [];
            const script = document.getElementById('scriptInput').value.toLowerCase();
            

            
            // Search in subtitles
            subtitleData.forEach((sub, index) => {
                if (sub.text.toLowerCase().includes(query)) {
                    const position = (sub.start / timelineData.length) * 100;
                    // Build wide context by combining surrounding subtitle entries
                    const contextText = buildSubtitleContext(index);
                    results.push({
                        source: 'Subtitle',
                        query: query,
                        position: Math.min(position, 100),
                        time: formatTime(sub.start),
                        text: contextText,
                        confidence: 'High'
                    });
                }
            });

            // Highlight in actual timeline if subtitles exist
            if (subtitleData.length > 0) {
                renderActualTimeline(query);
            }
            
            // Search in artifact list
            artifactList.forEach((artifact, index) => {
                if (artifact.name?.toLowerCase().includes(query) || 
                    artifact.keywords?.toLowerCase().includes(query)) {
                    const estimatedPosition = estimateArtifactPosition(artifact);
                    results.push({
                        source: 'Artifact List',
                        query: query,
                        position: estimatedPosition,
                        name: artifact.name,
                        confidence: 'Medium'
                    });
                }
            });
            
            // Display results
            displaySearchResults(results);
            
            if (results.length === 0) {
                showMessage('No matches found for your search.', 'error');
            } else {
                showMessage(`Found ${results.length} potential locations.`, 'success');
            }
        }

        function estimateArtifactPosition(artifact) {
            // Simple heuristic: estimate based on name patterns
            const name = artifact.name.toLowerCase();
            
            if (name.includes('intro') || name.includes('opening')) return INTRO_POSITION;
            if (name.includes('outro') || name.includes('ending') || name.includes('credits')) return OUTRO_POSITION;
            if (name.includes('middle') || name.includes('center')) return MIDDLE_POSITION;
            if (name.includes('transition')) return TRANSITION_MIN_POSITION + Math.random() * TRANSITION_RANGE;
            
            // Default: distribute evenly
            return Math.random() * 100;
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const frames = Math.floor((seconds % 1) * 30); // 30 fps
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}:${frames.toString().padStart(2, '0')}`;
        }

        function displaySearchResults(results) {
            const container = document.getElementById('searchResults');
            container.innerHTML = '';

            if (results.length === 0) {
                container.innerHTML = '<p style="color: #666;">No results found.</p>';
                return;
            }

            // Group results by source
            const groupedResults = {};
            results.forEach(result => {
                if (!groupedResults[result.source]) {
                    groupedResults[result.source] = [];
                }
                groupedResults[result.source].push(result);
            });

            // Display grouped results
            Object.keys(groupedResults).forEach(source => {
                const sourceDiv = document.createElement('div');
                sourceDiv.className = 'result-group';
                sourceDiv.innerHTML = `<h3>${source} Results (${groupedResults[source].length})</h3>`;

                groupedResults[source].forEach((result, index) => {
                    const div = document.createElement('div');
                    div.className = 'result-item';
                    const timeCode = result.time || formatTime((result.position / 100) * timelineData.length);
                    const isScriptResult = result.source === 'Script';
                    const isSubtitleResult = result.source === 'Subtitle';

                    let contextHtml = '';
                    if (result.text) {
                        if (isSubtitleResult) {
                            contextHtml = `<br>Context: ${getColoredContextWithSlider(result.text, result.query)}`;
                        } else {
                            contextHtml = `<br><small>Context: "${result.text.substring(0, 100)}..."</small>`;
                        }
                    }

                    div.innerHTML = `
                        <strong>${result.query}</strong> found in <em>${result.source}</em><br>
                        Estimated position: <strong>${result.position.toFixed(2)}%</strong>
                        ${result.time ? `(${result.time})` : ''}<br>
                        Confidence: ${result.confidence}
                        ${contextHtml}
                        <br><button onclick="copyToClipboard('${timeCode}')">üìã Copy Time Code</button>
                        ${isScriptResult ? `<button onclick="findInEstimatedTimeline('${result.query}')">üîç Estimated</button>` : ''}
                        ${isSubtitleResult ? `<button onclick="findInActualTimeline('${result.query}')">üé¨ Actual</button><button onclick="copyLuaScript('${timeCode}')">üêç Lua</button>` : ''}
                    `;
                    sourceDiv.appendChild(div);
                });

                container.appendChild(sourceDiv);
            });
        }

        function addToTimeline(name, position, time) {
            const artifact = {
                name: name,
                position: Math.min(Math.max(position, 0), 100),
                time: time || formatTime((position / 100) * timelineData.length),
                color: getRandomColor()
            };
            
            timelineData.artifacts.push(artifact);
            saveTimelineData();
            showMessage(`"${name}" added to timeline at ${position.toFixed(2)}%`, 'success');
        }

        function placeAllArtifacts() {
            if (artifactList.length === 0) {
                showMessage('No artifacts to place. Please upload an artifact list first.', 'error');
                return;
            }
            
            timelineData.artifacts = [];
            
            artifactList.forEach((artifact, index) => {
                const position = estimateArtifactPosition(artifact);
                const time = (position / 100) * timelineData.length;
                
                timelineData.artifacts.push({
                    name: artifact.name,
                    position: position,
                    time: formatTime(time),
                    color: getRandomColor()
                });
            });
            
            saveTimelineData();
            showMessage(`Placed ${artifactList.length} artifacts on timeline.`, 'success');
        }

        function getRandomColor() {
            return ARTIFACT_COLORS[Math.floor(Math.random() * ARTIFACT_COLORS.length)];
        }

        function showArtifactDetails(artifact) {
            alert(`Artifact: ${artifact.name}\nPosition: ${artifact.position.toFixed(2)}%\nTime: ${artifact.time}`);
        }

        function updateArtifactList() {
            const container = document.getElementById('artifactList');
            if (timelineData.artifacts.length === 0) {
                container.innerHTML = '<p style="color: #666;">No artifacts placed on timeline yet.</p>';
                return;
            }
            
            let html = '<strong>Artifacts on Timeline:</strong><br>';
            timelineData.artifacts.forEach((artifact, index) => {
                html += `
                    <div style="display: inline-block; margin: 5px; padding: 5px 10px; background: ${artifact.color}; color: white; border-radius: 5px; font-size: 0.9em;">
                        ${artifact.name} @ ${artifact.position.toFixed(1)}%
                        <button onclick="removeArtifact(${index})" style="margin-left: 5px; padding: 2px 6px; font-size: 0.8em;">√ó</button>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        function removeArtifact(index) {
            timelineData.artifacts.splice(index, 1);
            saveTimelineData();
            showMessage('Artifact removed from timeline.', 'success');
        }

        function saveTimelineData() {
            setStorageItem('timeline_data', JSON.stringify(timelineData));
        }

        function loadTimelineData() {
            const data = getStorageItem('timeline_data');
            if (data) {
                timelineData = JSON.parse(data);
            }

            const length = getStorageItem('timeline_length');
            const unit = getStorageItem('timeline_unit');

            if (length) {
                timelineData.length = parseInt(length);
                setTimelineDropdowns(parseInt(length));
            }

            if (unit) {
                timelineData.unit = unit;
                document.getElementById('timelineUnit').value = unit;
            }

            const subtitles = getStorageItem('timeline_subtitles');
            if (subtitles) {
                subtitleData = JSON.parse(subtitles);
                renderActualTimeline();
                document.getElementById('keywordsSection').style.display = 'block';
            }
            loadKeywords();

            const artifacts = getStorageItem('timeline_artifacts');
            if (artifacts) {
                artifactList = JSON.parse(artifacts);
            }
        }

        // Cookie Management UI
        function viewStorageItems() {
            const container = document.getElementById('cookieList');
            const items = getAllStorageItems();

            if (Object.keys(items).length === 0) {
                container.innerHTML = '<p style="color: #666;">No stored data found.</p>';
            } else {
                let html = '<h3>Stored Data:</h3>';
                for (let [name, value] of Object.entries(items)) {
                    const displayValue = value.length > 50 ? value.substring(0, 50) + '...' : value;
                    html += `
                        <div class="cookie-item">
                            <span><strong>${name}:</strong> ${displayValue}</span>
                            <button onclick="clearStorageItem('${name}')" class="danger">Delete</button>
                        </div>
                    `;
                }
                container.innerHTML = html;
            }

            container.style.display = 'block';
        }

        function clearStorageItem(name) {
            removeStorageItem(name);
            showMessage(`Data "${name}" deleted successfully.`, 'success');
            viewStorageItems();
        }

        function clearAllStorageItems() {
            if (!confirm('Are you sure you want to delete all stored data? This will remove all saved data.')) {
                return;
            }

            const items = getAllStorageItems();
            for (let name in items) {
                removeStorageItem(name);
            }

            document.getElementById('cookieList').style.display = 'none';
            document.getElementById('scriptInput').value = '';
            timelineData.artifacts = [];

            showMessage('All stored data cleared successfully.', 'success');
        }

        function exportData() {
            const data = {
                script: getStorageItem('timeline_script'),
                timeline: timelineData,
                subtitles: subtitleData,
                artifacts: artifactList
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'timeline-spotter-data.json';
            a.click();
            URL.revokeObjectURL(url);
            
            showMessage('Data exported successfully.', 'success');
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = function(event) {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        if (data.script) {
                            setStorageItem('timeline_script', data.script);
                            document.getElementById('scriptInput').value = data.script;
                        }

                        if (data.timeline) {
                            timelineData = data.timeline;
                            saveTimelineData();
                        }

                        if (data.subtitles) {
                            subtitleData = data.subtitles;
                            setStorageItem('timeline_subtitles', JSON.stringify(subtitleData));
                        }

                        if (data.artifacts) {
                            artifactList = data.artifacts;
                            setStorageItem('timeline_artifacts', JSON.stringify(artifactList));
                        }

                        showMessage('Data imported successfully!', 'success');
                    } catch (error) {
                        showMessage('Error importing data: ' + error.message, 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showMessage(`'${text}' copied to clipboard!`, 'success');
            }).catch(err => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showMessage(`'${text}' copied to clipboard!`, 'success');
            });
        }





        function findInEstimatedTimeline(query) {
            if (document.getElementById('scriptTimelineSection').style.display !== 'none') {
                renderScriptTimeline(query);
                const section = document.getElementById('scriptTimelineSection');
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                showMessage('Estimated timeline not available (subtitles loaded).', 'error');
            }
        }

        function findInActualTimeline(query) {
            if (document.getElementById('actualTimelineSection').style.display !== 'none') {
                renderActualTimeline(query);
                const section = document.getElementById('actualTimelineSection');
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Also scroll to the highlighted row
                setTimeout(() => {
                    const highlighted = document.querySelector('.timeline-table tr.highlighted');
                    if (highlighted) {
                        highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            } else {
                showMessage('Actual timeline not available (no subtitles loaded).', 'error');
            }
        }

        let selectedEntries = [];

        function renderActualTimeline(highlightQuery = null) {
            const section = document.getElementById('actualTimelineSection');
            const tbody = document.getElementById('actualTimelineTable').querySelector('tbody');

            if (subtitleData.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            tbody.innerHTML = '';

            // Load selected entries from storage
            const savedSelected = getStorageItem('selected_entries');
            if (savedSelected) {
                selectedEntries = JSON.parse(savedSelected);
            }

            subtitleData.forEach((sub, index) => {
                const startFormatted = formatTime(sub.start);
                const endFormatted = formatTime(sub.end);
                const isSelected = selectedEntries.includes(index);
                const isHighlighted = highlightQuery && sub.text.toLowerCase().includes(highlightQuery.toLowerCase());

                const row = document.createElement('tr');
                if (isHighlighted) {
                    row.classList.add('highlighted');
                }
                row.innerHTML = `
                    <td><input type="checkbox" ${isSelected ? 'checked' : ''} onchange="toggleEntrySelection(${index})"></td>
                    <td class="time-col">${startFormatted}</td>
                    <td class="time-col">${endFormatted}</td>
                    <td class="text-col">${sub.text}</td>
                    <td class="actions-col">
                        <button onclick="copyToClipboard('${startFormatted}')">üìã Start</button>
                        <button onclick="copyToClipboard('${endFormatted}')">üìã End</button>
                        <button onclick="copyLuaScript('${startFormatted}')">üêç Lua</button>
                    </td>
                `;
                tbody.appendChild(row);
            });

            updateSelectAllCheckbox();
        }

        function toggleEntrySelection(index) {
            if (selectedEntries.includes(index)) {
                selectedEntries = selectedEntries.filter(i => i !== index);
            } else {
                selectedEntries.push(index);
            }
            setStorageItem('selected_entries', JSON.stringify(selectedEntries));
            updateSelectAllCheckbox();
        }

        function toggleAllCheckboxes() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const checkboxes = document.querySelectorAll('#actualTimelineTable tbody input[type="checkbox"]');

            if (selectAllCheckbox.checked) {
                selectedEntries = [];
                checkboxes.forEach((cb, index) => {
                    cb.checked = true;
                    selectedEntries.push(index);
                });
            } else {
                selectedEntries = [];
                checkboxes.forEach(cb => cb.checked = false);
            }
            setStorageItem('selected_entries', JSON.stringify(selectedEntries));
        }

        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const checkboxes = document.querySelectorAll('#actualTimelineTable tbody input[type="checkbox"]');
            const checkedBoxes = document.querySelectorAll('#actualTimelineTable tbody input[type="checkbox"]:checked');

            selectAllCheckbox.checked = checkboxes.length > 0 && checkedBoxes.length === checkboxes.length;
            selectAllCheckbox.indeterminate = checkedBoxes.length > 0 && checkedBoxes.length < checkboxes.length;
        }

        function selectAllEntries() {
            selectedEntries = [];
            const checkboxes = document.querySelectorAll('#actualTimelineTable tbody input[type="checkbox"]');
            checkboxes.forEach((cb, index) => {
                cb.checked = true;
                selectedEntries.push(index);
            });
            setStorageItem('selected_entries', JSON.stringify(selectedEntries));
            updateSelectAllCheckbox();
        }

        function deselectAllEntries() {
            selectedEntries = [];
            const checkboxes = document.querySelectorAll('#actualTimelineTable tbody input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            setStorageItem('selected_entries', JSON.stringify(selectedEntries));
            updateSelectAllCheckbox();
        }

        function exportSelectedAsSRT() {
            if (selectedEntries.length === 0) {
                showMessage('No entries selected for export.', 'error');
                return;
            }

            let srtContent = '';
            selectedEntries.forEach((index, srtIndex) => {
                const sub = subtitleData[index];
                const startFormatted = formatTimeToSRT(sub.start);
                const endFormatted = formatTimeToSRT(sub.end);

                srtContent += `${srtIndex + 1}\n`;
                srtContent += `${startFormatted} --> ${endFormatted}\n`;
                srtContent += `${sub.text}\n\n`;
            });

            const blob = new Blob([srtContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'selected-subtitles.srt';
            a.click();
            URL.revokeObjectURL(url);

            showMessage(`Exported ${selectedEntries.length} selected entries as SRT.`, 'success');
        }

        function formatTimeToSRT(seconds) {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
        }

        function toggleTimelineExpansion() {
            const container = document.getElementById('timelineContainer');
            const btn = document.getElementById('expandBtn');

            if (container.style.maxHeight === 'none' || !container.style.maxHeight) {
                container.style.maxHeight = '400px';
                btn.textContent = 'üîΩ Expand';
            } else {
                container.style.maxHeight = 'none';
                btn.textContent = 'üîº Collapse';
            }
        }

        function copyLuaScript(timecode) {
            const luaScript = `local resolve = Resolve()
if resolve then
    local projectManager = resolve:GetProjectManager()
    local project = projectManager:GetCurrentProject()
    if project then
        local timeline = project:GetCurrentTimeline()
        if timeline then
            timeline:SetCurrentTimecode("${timecode}")
            print("Jumped to timecode: ${timecode}")
        else
            print("No active timeline found")
        end
    else
        print("No active project found")
    end
else
    print("DaVinci Resolve not found")
end`;
            copyToClipboard(luaScript);
        }

        // Store context data for slider lookups
        const contextDataStore = {};
        const BUFFER_SIZE = 100;  // 100 words loaded around the search term
        const VISIBLE_SIZE = 25;  // 25 words visible at a time in the textbox

        function getColoredContextWithSlider(text, query) {
            const allWords = text.split(/\s+/);
            const queryLower = query.toLowerCase();
            const queryWordIndex = allWords.findIndex(word => word.toLowerCase().includes(queryLower));

            if (queryWordIndex === -1) {
                const limitedText = allWords.slice(0, VISIBLE_SIZE).join(' ');
                return `<div style="width: 100%; border: 1px solid #ddd; padding: 8px; border-radius: 4px; background: #f9f9f9;">${limitedText}${allWords.length > VISIBLE_SIZE ? '...' : ''}</div>`;
            }

            const contextId = 'context_' + Math.random().toString(36).substr(2, 9);

            // Extract a 100-word buffer centered on the search term
            let bufferStart = Math.max(0, queryWordIndex - Math.floor(BUFFER_SIZE / 2));
            if (bufferStart + BUFFER_SIZE > allWords.length) {
                bufferStart = Math.max(0, allWords.length - BUFFER_SIZE);
            }
            const bufferEnd = Math.min(allWords.length, bufferStart + BUFFER_SIZE);
            const bufferWords = allWords.slice(bufferStart, bufferEnd);

            // The query word index relative to the buffer
            const queryInBuffer = queryWordIndex - bufferStart;

            // Slider controls which 25-word slice of the buffer is visible
            // Start the slider so the search term is centered in the visible 25 words
            const maxSlider = Math.max(0, bufferWords.length - VISIBLE_SIZE);
            let initialSlider = Math.max(0, queryInBuffer - Math.floor(VISIBLE_SIZE / 2));
            initialSlider = Math.min(initialSlider, maxSlider);

            // Store data for the slider handler
            contextDataStore[contextId] = { bufferWords, queryInBuffer, bufferStart, totalWords: allWords.length };

            // Build initial visible slice
            const initialHtml = buildContextHtml(contextId, initialSlider);

            const sliderHtml = `
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
                    <span style="font-size: 0.75em; color: #999;">&#9664;</span>
                    <input type="range" min="0" max="${maxSlider}" value="${initialSlider}" style="flex: 1; accent-color: #667eea;" oninput="updateContextWindow('${contextId}', this.value)">
                    <span style="font-size: 0.75em; color: #999;">&#9654;</span>
                    <span id="${contextId}_pos" style="font-size: 0.8em; color: #666; min-width: 100px; text-align: right;">words ${initialSlider + 1}-${Math.min(initialSlider + VISIBLE_SIZE, bufferWords.length)} / ${bufferWords.length}</span>
                </div>
                <div id="${contextId}" style="width: 100%; border: 1px solid #ddd; padding: 10px; border-radius: 4px; background: #f9f9f9; min-height: 28px; font-size: 0.95em; line-height: 1.6; white-space: normal; word-wrap: break-word;">${initialHtml}</div>
            `;

            return sliderHtml;
        }

        function buildContextHtml(contextId, sliderPos) {
            const data = contextDataStore[contextId];
            if (!data) return '';
            const { bufferWords, queryInBuffer, bufferStart, totalWords } = data;

            const viewStart = parseInt(sliderPos);
            const viewEnd = Math.min(bufferWords.length, viewStart + VISIBLE_SIZE);

            let displayText = '';

            // Show "..." if there's more text before the visible window
            if (bufferStart > 0 || viewStart > 0) displayText += '... ';

            for (let i = viewStart; i < viewEnd; i++) {
                const word = bufferWords[i];
                if (i === queryInBuffer) {
                    displayText += `<span style="background-color: #ffeb3b; font-weight: bold; padding: 1px 3px; border-radius: 3px;">${word}</span> `;
                } else {
                    displayText += word + ' ';
                }
            }

            // Show "..." if there's more text after the visible window
            if (viewEnd < bufferWords.length || (bufferStart + bufferWords.length) < totalWords) {
                displayText = displayText.trim() + ' ...';
            }

            return displayText.trim();
        }

        function updateContextWindow(contextId, sliderPos) {
            const data = contextDataStore[contextId];
            if (!data) return;

            const viewStart = parseInt(sliderPos);
            const viewEnd = Math.min(data.bufferWords.length, viewStart + VISIBLE_SIZE);

            document.getElementById(contextId).innerHTML = buildContextHtml(contextId, sliderPos);

            const posEl = document.getElementById(contextId + '_pos');
            if (posEl) {
                posEl.textContent = `words ${viewStart + 1}-${viewEnd} / ${data.bufferWords.length}`;
            }
        }

        let keywords = [];

        function extractKeywordsFromSubtitles() {
            const wordMap = new Map();

            subtitleData.forEach(sub => {
                const words = sub.text.toLowerCase().match(/\b\w+\b/g) || [];
                words.forEach(word => {
                    if (word.length > 2) { // Skip very short words
                        wordMap.set(word, (wordMap.get(word) || 0) + 1);
                    }
                });
            });

            // Sort by frequency, take top keywords
            const sortedWords = Array.from(wordMap.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 100) // Top 100 most frequent
                .map(([word]) => word);

            return sortedWords;
        }

        function displayKeywords() {
            const container = document.getElementById('keywordsContainer');
            container.innerHTML = '';

            keywords.forEach(keyword => {
                const tag = document.createElement('span');
                tag.className = 'keyword-tag';
                tag.textContent = keyword;
                tag.onclick = () => addKeywordToSearch(keyword);
                container.appendChild(tag);
            });

            // Update datalist for autocomplete
            const datalist = document.getElementById('keywordsList');
            datalist.innerHTML = '';
            keywords.forEach(keyword => {
                const option = document.createElement('option');
                option.value = keyword;
                datalist.appendChild(option);
            });
        }

        function addKeywordToSearch(keyword) {
            const searchInput = document.getElementById('searchQuery');
            const currentValue = searchInput.value.trim();
            if (currentValue) {
                searchInput.value = currentValue + ' ' + keyword;
            } else {
                searchInput.value = keyword;
            }
            searchInput.focus();
        }



        function regenerateKeywords() {
            if (subtitleData.length === 0) {
                showMessage('No subtitles loaded to extract keywords from.', 'error');
                return;
            }
            keywords = extractKeywordsFromSubtitles();
            displayKeywords();
            setStorageItem('custom_keywords', JSON.stringify(keywords));
            showMessage('Keywords regenerated from subtitles!', 'success');
        }

        function loadKeywords() {
            const saved = getStorageItem('custom_keywords');
            if (saved) {
                keywords = JSON.parse(saved);
                displayKeywords();
            }
        }

        function showMessage(message, type) {
            const successDiv = document.getElementById('successMessage');
            const errorDiv = document.getElementById('errorMessage');

            successDiv.style.display = 'none';
            errorDiv.style.display = 'none';

            if (type === 'success') {
                successDiv.textContent = message;
                successDiv.style.display = 'block';
                setTimeout(() => successDiv.style.display = 'none', 5000);
            } else {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                setTimeout(() => errorDiv.style.display = 'none', 5000);
            }
        }

        // Initialize on page load
        window.onload = function() {
            loadTimelineData();
        };
    </script>
</body>
</html>
